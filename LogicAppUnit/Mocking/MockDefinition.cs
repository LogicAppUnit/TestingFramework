using LogicAppUnit.Helper;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Threading.Tasks;

namespace LogicAppUnit.Mocking
{
    /// <summary>
    /// Handles the matching of mock requests and generates the corresponding mock response.
    /// </summary>
    internal class MockDefinition
    {
        // Request matchers and response builders that are configured using the fluent API
        private readonly List<MockResponse> _mockResponses;

        // Delegate function that creates a response from a request
        private Func<HttpRequestMessage, HttpResponseMessage> _mockResponseDelegate;

        // A log of requests sent to the mock test server that are generated by the workflow during its execution.
        // Use a ConcurrentBag to store the requests during the test execution to ensure thread safety of this collection
        private readonly ConcurrentBag<MockRequest> _mockRequestLog;
        private List<MockRequest> _mockRequestLogAsList;

        // A log for request matching, this can be used to understand how requests are being matched, or not being matched!
        private readonly List<string> _requestMatchingLog;

        /// <summary>
        /// Initializes a new instance of the <see cref="MockDefinition"/> class.
        /// </summary>
        public MockDefinition()
        {
            _mockResponses = new List<MockResponse>();
            _mockRequestLog = new ConcurrentBag<MockRequest>();
            _requestMatchingLog = new List<string>();

            // Hook up a default mock delegate
            _mockResponseDelegate = (request) => WrapDelegateDefinedInTestCase(request);
        }

        /// <summary>
        /// Configures a delegate function that creates a mocked response based on a request.
        /// </summary>
        public Func<HttpRequestMessage, HttpResponseMessage> MockResponseDelegate
        {
            set
            {
                _mockResponseDelegate = (request) => WrapDelegateDefinedInTestCase(request, value);
            }
        }

        /// <summary>
        /// Add a mocked response, consisting of a request matcher and a corresponding response builder.
        /// </summary>
        /// <param name="mockRequestMatcher">The request matcher.</param>
        /// <returns>The mocked response.</returns>
        public IMockResponse AddMockResponse(IMockRequestMatcher mockRequestMatcher)
        {
            MockResponse mockResponse = new MockResponse(mockRequestMatcher);
            _mockResponses.Add(mockResponse);
            return mockResponse;
        }

        /// <summary>
        /// Gets the mock requests that were created by the workflow during the test execution.
        /// </summary>
        /// <remarks>
        /// The requests are ordered in chronological order, with the most recent request at the start of the list.
        /// </remarks>
        public List<MockRequest> MockRequests
        {
            get
            {
                return _mockRequestLogAsList;
            }
        }

       /// <summary>
       /// Called when the test execution has completed.
       /// </summary>
       public void TestRunComplete()
       {
            // Copy the collection of mock requests from the thread-safe collection into a List that is accessible to the test case
            // The requests in the list are ordered in chronological order
            // The list is not thread-safe but this does not matter because the test case is not multi-threaded
            _mockRequestLogAsList = _mockRequestLog.OrderBy(x => x.Timestamp).ToList();

            // Write the request logs to the test output
            if (_mockRequestLogAsList.Count > 0)
            {
                Console.WriteLine("Mocked requests:");
                foreach (MockRequest req in _mockRequestLogAsList)
                {
                    Console.WriteLine($"    {req.Timestamp:HH:mm:ss.fff}");
                    Console.WriteLine($"      {req.Method} {req.RequestUri.AbsoluteUri}");
                }
            }
            else
            {
                Console.WriteLine("No mocked requests were logged");
            }
            Console.WriteLine();

            // Write the request matching logs to the test output
            // TODO: This logging needs to be controlled by a setting
            if (_requestMatchingLog.Count > 0)
            {
                Console.WriteLine("Mocked request matching logs:");
                _requestMatchingLog.ForEach(s => Console.WriteLine("    " + s));
            }
       }

        /// <summary>
        /// Match a HTTP request message and return the corresponding HTTP response message.
        /// </summary>
        /// <param name="request">The HTTP request message./</param>
        /// <returns>The HTTP response message.</returns>
        public async Task<HttpResponseMessage> MatchRequestAndBuildResponseAsync(HttpRequestMessage request)
        {
            if (request == null)
                throw new ArgumentNullException(nameof(request));

            // Cache the mock request to enable test assertions
            // Include anything that might be useful to the test author to validate the workflow
            _mockRequestLog.Add(new MockRequest
            {
                RequestUri = request.RequestUri,
                Method = request.Method,
                Headers = CopyHeaders(request.Headers),
                Content = await request.Content.ReadAsStringAsync(),
                ContentHeaders = CopyHeaders(request.Content.Headers)
            });

            // Use fluent mock reponses first, then the mock response delegate
            HttpResponseMessage response = null;
            if (_mockResponses.Count > 0)
            {
                _requestMatchingLog.Add($"Checking {_mockResponses.Count} mock request matchers:");
                response = await GetResponseUsingFluentMocksAsync(request);
            }
            else
            {
                _requestMatchingLog.Add("No mock request matchers have been configured");
            }

            if (response != null)
                return response;
            else
            {
                _requestMatchingLog.Add("Runing mock response delegate because no requests were matched");
                return _mockResponseDelegate(request);
            }
        }

        /// <summary>
        /// Match a HTTP request message against the set of request matchers and return the corresponding HTTP response message.
        /// </summary>
        /// <param name="request">The HTTP request message./</param>
        /// <returns>The HTTP response message.</returns>
        public async Task<HttpResponseMessage> GetResponseUsingFluentMocksAsync(HttpRequestMessage request)
        {
            HttpResponseMessage matchedResponse = null;
            int count = 0;

            foreach (MockResponse mockResp in _mockResponses)
            {
                _requestMatchingLog.Add($"  Checking mock request matcher #{++count}");

                try
                {
                    matchedResponse = await mockResp.MatchRequestAndCreateResponseAsync(request, _requestMatchingLog);
                }
                catch (Exception ex)
                {
                    _requestMatchingLog.Add($"    EXCEPTION: {ex.Message}");
                    throw;
                }

                if (matchedResponse != null)
                    break;
            }

            return matchedResponse;
        }

        #region Private methods

        /// <summary>
        /// Wrap the mock delegate defined in the test case with additional functionality.
        /// </summary>
        /// <param name="httpRequestMessage">Request message for the mocked API call.</param>
        /// <param name="mockDefinedInTestCase">Delegate function that sets the response message for the mocked API call.</param>
        /// <returns>The response message.</returns>
        private static HttpResponseMessage WrapDelegateDefinedInTestCase(HttpRequestMessage httpRequestMessage, Func<HttpRequestMessage, HttpResponseMessage> mockDefinedInTestCase = null)
        {
            // Wire up the archive mock
            if (httpRequestMessage.RequestUri.AbsolutePath.Contains("Archive"))
                return GetMockArchiveResponse(httpRequestMessage);

            // And then wire up the mock responses defined in the test case
            // If there is no mock defined by the test case, return an empty response
            if (mockDefinedInTestCase == null)
                return new HttpResponseMessage();
            else
                return mockDefinedInTestCase(httpRequestMessage);
        }

        #endregion // Private methods

        #region Private static methods

        /// <summary>
        /// Copy a HTTP headers collection into a dictionary.
        /// </summary>
        /// <param name="headerCollection">The collection of headers.</param>
        /// <returns>A dictionary containing the headers.</returns>
        private static Dictionary<string, IEnumerable<string>> CopyHeaders(HttpHeaders headerCollection)
        {
            if (headerCollection == null)
                return null;

            Dictionary<string, IEnumerable<string>> col = new Dictionary<string, IEnumerable<string>>();
            foreach (var header in headerCollection)
            {
                col.Add(header.Key, header.Value);
            }
            return col;
        }

        /// <summary>
        /// Create a response message for the mocked archive API request.
        /// </summary>
        /// <param name="httpRequestMessage">Request message for the mocked API call.</param>
        /// <returns>The response message.</returns>
        private static HttpResponseMessage GetMockArchiveResponse(HttpRequestMessage httpRequestMessage)
        {
            if (httpRequestMessage == null)
                throw new ArgumentNullException(nameof(httpRequestMessage));

            HttpResponseMessage mockedResponse = new HttpResponseMessage
            {
                RequestMessage = httpRequestMessage,
                StatusCode = HttpStatusCode.OK,
                Content = ContentHelper.CreatePlainStringContent("archived")
            };

            return mockedResponse;
        }

        #endregion // Private static methods
    }
}
